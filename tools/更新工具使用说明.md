# D_sakiko 更新工具使用说明（`tools`）

本文档介绍本项目更新工具链的使用方法与原理。

一般来讲，一个软件的更新可以分为三个部分：

1. 开发者比对两个版本之间的差异，制作更新包
2. 用户通过各种方式下载到更新包
3. 用户电脑上的更新程序检测到更新包，执行更新

本目录下的代码文件包装了 hdiffpatch 工具，可以快速的实现第一步和第三步，尽可能完成更新发布流程的自动化。

在使用前，请先前往 https://github.com/sisong/HDiffPatch 的 releases 页面，下载适合你系统的两个文件：hdiffz 和 hpatchz，放在 tools 目录下。这两个文件需要在下次更新时分发给用户。

---

## 1. `build_diff_patch.py` 基础使用教程

`build_diff_patch.py` 的作用是：

- 比较“新版本目录”和“旧版本目录”
- 先按黑名单和白名单筛选文件，再比较这些筛选出的文件，确定它们的修改属于新增/修改/删除
- 用 `hdiffz` 生成目录差分文件（默认 `patch.hdiff`）
- 生成 `manifest.json`（在更新程序中用于版本校验与文件校验）
- 生成 `warnings_remove_files.txt`（提示会被删除的文件，用于人工核对）

### 1.1 前置条件

- 已有可执行的 `tools/hdiffz`
- 有新版本目录，建议新版本目录处于 git 开发环境下，以便程序通过查询 git 的跟踪文件来自动过滤掉未跟踪的临时文件。
- 有旧版本的完整目录（不需要在 git 环境下）

### 1.2 最小命令结构

```bash
python tools/build_diff_patch.py \
  --current <新版本目录> \
  --old <旧版本目录> \
  --output <补丁输出目录> \
  --base-version <旧版本号> \
  --target-version <新版本号>
```

### 1.3 主要输出

执行后，`--output` 目录通常包含：

- `patch.hdiff`：二进制差分包（可用 `hpatchz` 应用）
- `manifest.json`：更新元数据（版本、文件动作、哈希、统计信息）
- `warnings_remove_files.txt`：删除文件提醒，用于人工核对删除的文件是否正确，程序并不需要；在实际发布的更新包中，可以删除此内容。

---

## 2. `DEFAULT_IGNORE` / `DEFAULT_INCLUDE` 的工作方式

在开发目录（新版本目录下），通常存在大量的临时文件或者不应当进入更新包的文件，比如 .git；为了发布新版本，直接删除/移动这些临时文件是非常麻烦的。因此，我们需要一套规则来自动过滤掉这些不必要的文件，避免它们进入更新包。

`build_diff_patch.py` 内有两套默认规则：

- `DEFAULT_IGNORE_PATTERNS`：默认忽略（黑名单）
- `DEFAULT_INCLUDE_PATTERNS`：默认强制包含（白名单）


具体的包含规则如下：

1. 如果一个文件在 `DEFAULT_INCLUDE_PATTERNS` 中，它一定会被保留在更新包中（即使它同时位于黑名单/没有被 git 追踪）
2. 如果一个文件在 `DEFAULT_IGNORE_PATTERNS` 中，并且不在 `DEFAULT_INCLUDE_PATTERNS` 中，那么它会被忽略。
3. 其他文件会被保留在更新包中；如果启用了 `--use-git-tracked`，但该文件没有被 git 追踪，那么它也会被忽略。

请注意：

忽略一个文件**不代表更新包更新后会删除此文件**。

忽略一个文件的含义是：**这个文件的修改（新增/修改/删除）不会被纳入更新包的差分计算**，也就是说：

- 如果这个文件本来不存在于旧版本中，那么它的新增不会被纳入更新包，更新后用户电脑上也不会有这个文件。
- 如果这个文件本来存在于旧版本中，那么它的修改或删除也不会被纳入更新包，更新后用户电脑上仍然会保留这个文件的旧版本内容。

当前脚本中的示例：

- `DEFAULT_IGNORE_PATTERNS` 包括：`.venv/*`、`.git/*`、`.vscode/*`、`tools/*`、部分构建/辅助文件等
- `DEFAULT_INCLUDE_PATTERNS` 包括：`GPT_SoVITS/live2d_1.cpython-311-darwin.so`

### 2.1 判定优先级

筛选规则的核心是：

1. 命中 `include`（白名单）=> 保留
2. 否则命中 `ignore`（黑名单）=> 忽略
3. 其他 => 保留

也就是：**白名单优先于黑名单**。

### 2.2 如何扩展/覆盖规则

可通过参数追加规则：

- `--ignore 'glob模式'`：追加忽略规则（可重复传入）
- `--include 'glob模式'`：追加强制包含规则（可重复传入）
- `--read-gitignore`：把仓库 `.gitignore` 也读进来作为忽略来源

示例：

```bash
python tools/build_diff_patch.py \
  ... \
  --read-gitignore \
  --ignore 'reference_audio/generated_audios_temp/*' \
  --ignore 'knowledge_base/rag_db/*' \
  --include 'GPT_SoVITS/live2d_1.cpython-311-darwin.so'
```

此外，也可以手动修改 build_diff_patch.py 中的 `DEFAULT_IGNORE_PATTERNS` 和 `DEFAULT_INCLUDE_PATTERNS` 常量列表来调整默认规则。

### 2.3 实操建议

- 发布稳定阶段：优先使用 `--read-gitignore --use-git-tracked`
- 对“必须进包但通常被忽略”的文件，用 `--include` 明确声明
- 对“用户本地数据目录”尽量加入 `--ignore`，避免误覆盖用户数据

请注意，所有的筛选规则都只针对**新版本目录**生效，旧版本目录不受任何规则影响，所有旧版本文件都会被纳入差分计算。

---

## 3. 标准打包命令示例与解析

以下是一条打包示例命令；这条命令是无法执行的，但我们可以通过它来讲解各个参数的含义和作用：

```bash
python tools/build_diff_patch.py --current . --old '/Users/a/Documents/D_sakiko_2.6.5_0217' --output ./patch_files --base-version "2.6.5" --target-version "2.7" --read-gitignore --use-git-tracked --clean-output
```

### 参数逐项说明

- `--current .`  
  使用当前目录作为新版本目录。

- `--old '/Users/.../D_sakiko_2.6.5_0217'`  
  指定旧版本完整目录。

- `--output ./patch_files`  
  将补丁产物输出到 `patch_files`。

- `--base-version "2.6.5"`  
  指明此补丁**只能应用在 2.6.5**。

- `--target-version "2.7"`  
  补丁应用成功后的目标版本号。更新后，version.json 中的版本会被自动更新为这个值。

- `--read-gitignore`  （推荐使用）
  把 `.gitignore` 纳入过滤规则，减少临时/开发文件混入。

- `--use-git-tracked`  （推荐使用）
  以 Git 跟踪文件作为新版本候选文件集，降低未跟踪脏文件误入包的风险。

- `--clean-output`  
  生成前清空 `patch_files`，避免旧产物残留污染。

### 常用增强参数

- `--hdiff-option -c-zstd`（或其他 hdiff 参数）  
  透传给 `hdiffz`，用于调整压缩策略。

- `--patch-file custom_name.hdiff`  
  自定义差分文件名。

- `--manifest custom_manifest.json`  
  自定义清单文件名。通常不应该更改这个名字，因为更新程序默认寻找 `manifest.json` 来读取更新信息。

---

## 4. 整体原理：`build_diff_patch.py` + `apply_update_patch.py`

### 4.1 构建端（`build_diff_patch.py`）

流程如下：

1. 读取参数与规则（默认规则 + 命令行规则 + 可选 `.gitignore`）
2. 获取新旧版本文件集合（可选 Git 跟踪模式）
3. 计算新增/修改/删除
4. 将筛选后的新旧目录复制到临时目录；其中，新版本目录只复制筛选后的文件，旧版本目录不会经过筛选。
5. 调用 `hdiffz` 产出 `patch.hdiff`
6. 生成 `manifest.json`（含 base/target 版本、文件动作、SHA256）

### 4.2 应用端（`apply_update_patch.py`）

流程如下：

1. 自动发现更新包（或使用 `--package` 指定）
   - 自动发现规则：主目录下子目录中同时存在 `manifest.json` 与 `patch.hdiff`
2. 读取当前版本，匹配 `base_version == 当前版本` 的更新包
3. 调用 `hpatchz` 将差分包还原到临时目录
4. 根据 `manifest.json` 执行复制/删除，并对文件进行 SHA256 校验
5. 进行后处理（如 `.command` 权限、quarantine 清理）
6. 写入新版本号到 `version.json`
7. 更新成功后删除已应用更新包目录
8. 若中途失败，执行回滚（恢复更新前文件）

### 4.3 为什么要有 `manifest.json`

`manifest.json` 是“补丁契约”，主要解决：

- 版本安全：防止跨版本误打补丁
- 文件一致性：通过哈希校验保证更新后文件正确
- 可审计：记录哪些文件新增/修改/删除
- 可恢复：配合回滚信息降低更新失败风险

---

## 常见问题（FAQ）

### Q1：为什么补丁里会缺少某个文件？

优先检查：

- 是否被 `DEFAULT_IGNORE_PATTERNS` 或 `.gitignore` 忽略
- 是否没有被 Git 跟踪（且使用了 `--use-git-tracked`）
- 尝试通过 `--include` 强制包含

### Q2：中文文件名会不会受影响？

不会。`build_diff_patch.py` 使用 `git ls-files -z` 读取跟踪文件，可正确处理中文路径。

### Q3：更新包会自动删除吗？

会。`apply_update_patch.py` 在成功应用后会删除该更新包目录；删除失败会告警但不影响已完成更新。

---

## 推荐发布流程（简版）

1. 准备旧版本完整包目录
2. 在新版本代码目录执行 `build_diff_patch.py`
3. 检查 `warnings_remove_files.txt` 与 `manifest.json`。检查无误后，可以选择删除 `warnings_remove_files.txt`。
4. 将补丁目录投放到用户主目录下（或指定 `--package`）
5. 运行 `apply_update_patch.py` 或者主目录下的 `执行更新.bat` 执行更新
6. 验证版本号与主程序运行状态
